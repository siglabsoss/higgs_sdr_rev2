// ===========================================================================
// Verilog module generated by IPexpress
// Filename: test_ts_mac.v  
// Copyright 2005 (c) Lattice Semiconductor Corporation. All rights reserved.
// ===========================================================================

`timescale 1 ns/100 ps

module  test_ts_mac ;

`include "env_params.v"
`include "test_tsmac_params.v"


reg         reset_n ;
reg         tx_clk_125 ;
reg         rx_clk_125 ;
reg         tx_clk_25 ;
reg         rx_clk_25 ;
reg         clk_125 ;
reg         clk_12_5 ;
reg         sys_clk ;
reg         hclk ;

wire gtx_clk;
wire tx_en;
wire tx_er;
wire [7:0] txd;

wire tx_clk;
wire rx_clk;

`ifdef MIIM_MODULE
   tri mdio;
`endif

reg [7:0] rxd;
reg rxer;
reg rxdv;
reg col;
reg crs;

reg tdi;
reg tms;
reg tck;

wire rxmac_clk_wire;
wire txmac_clk_wire;
wire rxmac_clk;
wire txmac_clk;

// test points
wire [7:0] tx_fifodata;  
wire tx_fifoavail;   
wire tx_fifoeof;     
wire tx_fifoempty;   
wire tx_sndpausreq;  
wire tx_fifoctrl;    
wire tx_fifo_full_ri;
wire tx_macread;     
wire tx_discfrm;     
wire tx_staten;      
wire tx_done; 
wire gbit_en; // gbit_en signal

`ifdef SGMII_TSMAC
   wire txmac_clk_en;
   wire rxmac_clk_en;
   wire clk_en_1000;
   reg  clk_en_100_tx;
   reg  clk_en_100_rx;
`endif
	
initial begin
   reset_n = 1;
   #50;
   reset_n = 0;
   #100;
   reset_n = 1;
end

initial begin
   col = 0;
   tx_clk_125 = 0;
   rx_clk_125 = 0;
   tx_clk_25 = 0;
   rx_clk_25 = 0;
   clk_125 = 0;
   clk_12_5 = 0;
   hclk = 0;
   sys_clk = 0;
   rxd = 8'h00;
   rxdv = 0;
   rxer = 0;
   crs = 0;
   `ifdef SGMII_TSMAC
         clk_en_100_tx = 0;
         clk_en_100_rx = 0;
   `endif
   tdi = 0;
   tms = 0;
   tck = 0;
   
   `ifdef GBE_MAC
   `else
`ifdef GATE_SIM_VHD
   force U1_ts_mac_top.gbit_en_c = 1;
   #40;
   release U1_ts_mac_top.gbit_en_c;
`else
   force U1_ts_mac_top.gbit_en_wire = 1;
   #40;
   release U1_ts_mac_top.gbit_en_wire;
`endif
   `endif
   
   //force U1_ts_mac_top.U1_ts_mac_core.U1_tx_mac.U1_tx_readfifo.tx_fifodata = 0;
   //#300;
   //release U1_ts_mac_top.U1_ts_mac_core.U1_tx_mac.U1_tx_readfifo.tx_fifodata;
   
   //#85000
   //#103000
   //force U1_ts_mac_top.u1_tst_logic.tx_fifo_empty_ri = 1;
   //#1000;
   //release U1_ts_mac_top.u1_tst_logic.tx_fifo_empty_ri;
end

GSR GSR_INST	(.GSR(reset_n)) /* synthesis syn_noprune = 1 */ ;
PUR PUR_INST	(.PUR(1'b1)) /* synthesis syn_noprune = 1 */ ;
//TSALL TSALL_INST (1'b1) /* synthesis syn_noprune = 1 */ ;

`ifdef CLASSIC_TSMAC
    assign tx_clk = (gbit_en) ? tx_clk_125:tx_clk_25;
    assign rx_clk = (gbit_en) ? rx_clk_125:rx_clk_25;
`else // SGMII_TSMAC OR GBE_MAC
    assign tx_clk = tx_clk_125;
    assign rx_clk = rx_clk_125;
`endif

// rxmac_clk goes to rx_gen_task to drive pkts
`ifdef SGMII_TSMAC
    assign rxmac_clk = (gbit_en) ? clk_125:clk_12_5; //
`else // CLASSIC_TSMAC OR GBE_MAC
    assign rxmac_clk = rxmac_clk_wire;
`endif


	ts_mac_top U1_ts_mac_top (

		// clock and reset

		.gtx_clk (gtx_clk),
		.tx_clk (tx_clk),

                `ifdef SGMII_TSMAC
		   .txmac_clk_en (txmac_clk_en),
		   .rxmac_clk_en (rxmac_clk_en),
                `endif
		
                `ifdef MIIM_MODULE
	    	   .mdc (mdc),
                `endif

		.sys_clk (sys_clk),
		.hclk (hclk),
		.rx_clk (rx_clk),
		.rxmac_clk (rxmac_clk_wire),
		.txmac_clk (txmac_clk_wire),
		.reset_n (reset_n),
		
		// Input signals to the GMII
		.rx_dv (rxdv),
		.rx_er (rxer),
		.rxd (rxd),
		
                `ifndef GBE_MAC
		  .col (col),
		  .crs (crs),
                `endif
		
                // orcastra interface
   		.pc_clk (pc_clk),
   		.pc_datain (pc_datain),
   		.pc_dataout (pc_dataout),
   		.pc_retry (pc_retry),
   		.pc_error (pc_error),
   		.pc_ready (pc_ready),
   		.pc_ack (pc_ack),
   		.jtag_present (),
   		.jtag_parallel (1'b0),

		// JTAG Signals 
		.tdi (tdi),
		.tms (tms),
		.tck (tck),
		.tdo (),

		// Input/Output signal from the MII Management Interface
                `ifdef MIIM_MODULE
		   .mdio (mdio),
                `endif

		// Output signals from the GMII
		.tx_en (tx_en),
		.tx_er (tx_er),
		.txd (txd),
		
		// These are test points on the evaluation board
		.tx_fifodata (tx_fifodata),
		.tx_fifoavail (tx_fifoavail),
		.tx_fifoeof (tx_fifoeof),
		.tx_fifoempty (tx_fifoempty),
		.tx_sndpausreq (tx_sndpausreq),
		.tx_fifoctrl (tx_fifoctrl),
		.tx_fifo_full_ri (tx_fifo_full_ri),
		.tx_macread (tx_macread),
		.tx_discfrm (tx_discfrm),
		.tx_staten (tx_staten),
		.tx_done (tx_done),
		.gbit_en (gbit_en),
                .phy_reset_n(phy_reset_n)
		);



	orcastra_drv orcastra_drv(
   		.pc_clk (pc_clk),
     	        .pc_datain (pc_datain),
   		.pc_dataout (pc_dataout),
   		.pc_retry (pc_retry),
   		.pc_error (pc_error),
   		.pc_ready (pc_ready),
   		.pc_ack (pc_ack)
   		);

		
       pkt_mon pkt_mon(
		.reset_n (reset_n),
		
		`ifdef SGMII_TSMAC
		  .gbit_en (1'b1),
    		  .tx_clk_en (txmac_clk_en),
	        `else
		  .gbit_en (gbit_en),
	        `endif
		
    		.tx_clk (tx_clk),
		.tx_en (tx_en),
		.tx_er (tx_er),
		.txd (txd)
		);

		
       //jtag_drv jtag_drv (
       //   .PTDO ( tdo ), 
       //   .PTCK ( tck ), 
       //   .PTDI ( tdi ), 
       //   .PTMS ( tms )
       //   );

`define SRC_NIB11 4'hd
`define SRC_NIB10 4'he
`define SRC_NIB9 4'ha
`define SRC_NIB8 4'hd
`define SRC_NIB7 4'hd
`define SRC_NIB6 4'he
`define SRC_NIB5 4'ha
`define SRC_NIB4 4'hd
`define SRC_NIB3 4'hb
`define SRC_NIB2 4'he
`define SRC_NIB1 4'he
`define SRC_NIB0 4'hf
// =============================================================================
`include "rx_gen_tasks.v"
`include "testcase.v"
`include "rdwr_task.v"
// =============================================================================


// Clocks generation
// 125 Mhz clock
always #4 clk_125 = ~clk_125 ;
always #4 tx_clk_125 = ~tx_clk_125 ;
always #4 rx_clk_125 = ~rx_clk_125 ;
always #20 tx_clk_25 = ~tx_clk_25 ;
always #20 rx_clk_25 = ~rx_clk_25 ;
always #40 clk_12_5 = ~clk_12_5 ;
// 125 Mhz clock
always #4 sys_clk = ~sys_clk ;
// 50 Mhz clock
always #10 hclk = ~hclk;

// Clock enable generation
`ifdef SGMII_TSMAC

        assign clk_en_1000 = 1'b1;
	
	always @(posedge clk_125) begin
	       	#72 clk_en_100_tx = 1'b1;
	        #8  clk_en_100_tx = 1'b0;
	end	
        
	always @(posedge clk_125) begin
	       	#72 clk_en_100_rx = 1'b1;
	        #8  clk_en_100_rx = 1'b0;
	end
	
	assign txmac_clk_en = (gbit_en) ? clk_en_1000:clk_en_100_tx;
        assign rxmac_clk_en = (gbit_en) ? clk_en_1000:clk_en_100_rx;
		
`endif

initial begin
     $timeformat (-9 ,1 , "ns", 10);
end

// Timeout generation to finish hung test cases.
initial begin
   repeat (10000000) @(posedge clk_125 );
   $display(" INFO : Simulation Time Out, Test case Terminated") ;
   $finish ;
end

endmodule
// =============================================================================



